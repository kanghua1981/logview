# 🚀 LogView: 极速日志分析工作站

> **告别 grep + 文本编辑器的原始时代。这是一款专为开发者设计的、具备"工程思维"的日志深度分析工具。**

## 🌟 核心设计理念：从"看日志"到"析逻辑"

在处理数百万行的海量日志时，由于干扰信息（Noise）太多，传统的全局搜索往往无法让我们看清真正的业务流。LogView 通过**"脱水分析"**、**"关键路径追踪"**与**"多级面包屑过滤"**，让日志分析效率提升 **10 倍**以上。

---

## 🛠️ 主打功能点

### 1. 关键路径追踪 (KeyPath Trace) —— *骨架提取利器*

*   **多色高亮**：为 `Request`, `Response`, `Error` 等业务关键词分配不同颜色，建立视觉识别系统。
*   **脱水模式**：一键开启"仅看追踪"，瞬间过滤掉 99% 的垃圾信息，只留下你关心的业务执行链条。
*   **上下文轮廓 (Context Lines)**：可配置在追踪行前后显示 N 行上下文，在聚焦关键路径的同时保留必要的环境信息。
*   **$\Delta$ 时间差**：系统自动计算相邻追踪行之间的时间差，性能瓶颈（如接口响应慢）一眼识破。

### 2. 🍞 多级面包屑过滤 (Cascading Filters) —— *层层递进的手术刀*

> **这是 LogView 的杀手级特性！** 告别传统的"一次性全局搜索"，采用"面包屑导航"式的渐进式筛选。

**工作原理：**
1. **一级筛选 (文件范围)**：选择你要分析的日志文件。
2. **二级筛选 (Session 范围)**：选择特定的启动会话或时间区间。
3. **三级筛选 (踪迹模式)**：启用脱水模式，只显示你标记的关键字（OR 关系）。
4. **四级及以上 (精细过滤)**：在当前结果基础上，通过**级联输入框**逐层添加 AND 条件。

**⚡ VI 风格命令模式 (全新升级！)**
*   **🎯 免鼠标操作**：在日志视图的任何位置，直接输入任意字母或数字，系统会自动聚焦顶部过滤框并开始实时过滤。
*   **🔧 命令前缀切换**：通过前缀键快速切换过滤模式（按两次相同前缀取消）：
    *   `!` → **Exclude 模式**（红色）
    *   `/` → **Regex 模式**（紫色）
    *   `=` → **Exact 模式**（绿色）
    *   `:` → **Command 模式**（琥珀色）：控制指令
        *   `:o` / `:open`：直接唤起文件选择对话框打开新日志。
        *   `:top` / `:t`：直达日志顶部。
        *   `:bot` / `:b`：直达日志底部。
        *   `:500`：跳转到第 500 行。
        *   `:export` / `:exp`：导出当前过滤后的视图内容。
        *   `:clear`：清空所有已锁定的面包屑过滤器。
    *   `@` → **Time 模式**（青色）：`@10:30:05` 快速定位时间点    *   `?` → **AI 智能分析模式**（蓝色）：🤖 与大模型对话，获取智能诊断建议（详见 AI 功能章节）*   **⌨️ Esc 键盘导航**：
    *   如果输入框处于聚焦状态：按 `Esc` 退出聚焦（Blur），同时清空预览内容
    *   如果输入框未聚焦：按 `Esc` 删除最后一个已固化的面包屑过滤器（逐级后退）
*   **🎨 视觉反馈**：顶部面包屑和模式徽章会根据不同模式显示不同颜色，让你一眼识别当前过滤路径的组成。

**两种过滤模式：**
*   **实时过滤**：在输入框中打字时，结果即时响应，帮你快速试探最佳关键词。
*   **固化过滤**：按下 `Enter` 键，当前关键词（连同模式前缀）会转化为面包屑标签并锁定，成为过滤路径的一部分。继续输入下一级条件，实现"逐层深挖"。


**使用场景示例：**
```
📁 system.log (200万行) 
  → 🔄 Session #5 (筛选到8万行)
    → 🎯 踪迹模式: "video_callback" (筛选到2000行)
      → 🔎 实时输入: "640x360" (动态显示匹配的200行)
        → ✅ 回车固化: "640x360" (锁定为面包屑)
          → 🔎 再次输入: "12fps" (最终显示15行精准结果)
```

**面包屑导航的优势：**
*   ✅ **路径可视化**：顶部面包屑清晰显示你的分析路径，避免"迷失在复杂查询中"。
*   ✅ **快速回溯**：点击任意面包屑的 `×` 按钮，立即退回到上一层视图。
*   ✅ **团队协作**：导出配置时，面包屑路径会保存，同事可以一键复现你的分析过程。

### 3. 智能会话拆解 (Intelligent Session Analysis) —— *上下文即正义*

*   **模式识别**：内置智能算法，可根据 `BOOT`、`Timestamp` 或自定义正则自动切割冗长日志，将杂乱的文本流转化为有序的"业务会话"。
*   **会话导出与快照**：支持将筛选后的"纯净版"会话一键导出为独立文件（**带原始行号前缀**）。这对于提交 Bug 附件或与同事同步排障上下文极具价值——不再需要发送几个 GB 的原始日志，只发送"脱水后"的业务真相。
*   **焦点模式**：快速定位到某次特定的系统启动或任务执行，排除其他并发干扰。

### 4. 指标可视化分析 (Advanced Metrics & Dashboard) —— *数据驱动排障*

*   **自定义指标提取**：不仅是看文本，还可以通过正则表达式捕获日志中的数值（如：CPU 占用、内存水位、传感器数值），并自动生成历史趋势曲线图。
*   **异步流程跑分**：通过指定"起始"与"结束"标识，系统全量扫描日志并自动匹配异步任务对，计算 P95/P99 延迟分位数。
*   **散点分布图**：通过可视化图表展示任务耗时分布。你可以一眼发现那些偏离正常范围的"慢任务"。
*   **图表联动跳转**：在仪表盘点击任意一个异常散点或指标拐点，日志区域会立即同步跳转至对应的原始代码行。

### 5. IDE 级搜索与极端性能

*   **百万级秒开**：基于 **Rust 后端 + Rayon 并行处理**，千万行日志在秒级完成载入与索引。所有过滤操作均在 Rust 层多线程执行，而非传统的 JavaScript 单线程处理。
*   **内存映射 (mmap)**：采用操作系统级别的文件映射技术，无需将整个文件加载到内存，支持超大文件的流式分析。
*   **独立查询面板**：`Ctrl + F` 调出类似 IDE 的底部查询预览，支持正则结果的一键持久化。
*   **动态视觉**：`Ctrl + 鼠标滚轮` 缩放，配合深色主题，长时间排障不疲劳。

### 6. 🔄 状态持久化与配置管理

*   **自动保存**：所有配置（正则表达式、高亮关键字、指标定义、级联过滤器）在本地自动持久化，刷新页面后状态完整恢复。
*   **方案导入导出**：将你的解析规则、追踪关键字导出为 `.json` 方案，分享给团队小伙伴。
*   **排障预设**：针对不同模块（如：串口加载、网络协议、UI渲染）保存不同的预设模式，实现"开箱即用"的一键排障环境。

### 7. 🤖 AI 智能诊断助手 (Agent Mode) —— *让大模型帮你读日志*

> **这是 LogView 的革命性升级！** 从"人工阅读日志"进化到"AI 自动诊断"。

**核心功能：**
*   **上下文感知分析**：AI 会自动读取你当前的面包屑过滤路径、会话范围和采样日志（智能采样前 200 行 + 后 200 行，避免 Token 超限）。
*   **根因定位**：只需输入 `? 为什么视频流断了` 或 `? 这些 ERROR 是什么原因导致的`，AI 会基于日志上下文给出专业分析。
*   **智能过滤建议**：AI 在分析过程中如果发现关键模式（如错误码、函数名、状态值），会主动建议过滤条件。你只需**点击一下**，建议就会自动应用到面包屑中。
*   **多轮对话支持**：在 AI 面板中可以持续追问，逐步深挖问题。所有对话历史会保留，方便回溯分析思路。

**配置灵活性：**
*   **支持任意 OpenAI 兼容接口**：不仅支持 OpenAI，还支持 DeepSeek、Claude、本地 Ollama 等任何符合 OpenAI API 标准的服务。
*   **自定义 System Prompt**：在配置面板中可以自定义 AI 的专家角色（如"你是一个嵌入式音视频专家"），让分析更贴合你的业务场景。
*   **技术协议自动注入**：无论你如何修改 Prompt，系统会自动在后面追加 `FILTER:` 格式协议，确保"点击应用建议"功能永不失效。

**使用示例：**
```
# 第一步：通过面包屑过滤到关注的范围
Session #5 → video_callback → 640x360 (剩余 200 行)

# 第二步：输入 AI 提问
? 这些日志里为什么会出现大量的 register_callback failed

# 第三步：AI 自动分析
AI 返回：
"根据采样分析，问题出在 10:28:45 时间段，
register_video_callback 和 register_audio_callback 
同时被调用导致资源冲突。主要涉及 TCL_CMD_VIDEOSTART 
和 TCL_CMD_AUDIOSTART 两个命令..."

推荐过滤建议：
[/] TCL_CMD_.*START || 过滤所有启动命令以观察调用时序
[!] dayhight_intelligent || 排除智能夜视模式的干扰日志

# 第四步：点击建议，自动应用过滤
点击第一个建议后，面包屑自动添加 /TCL_CMD_.*START
视图立即刷新，只显示 15 行关键启动命令
```

**AI 分析的最佳实践：**
1. **先过滤后提问**：不要直接在 200 万行全文上提问，先用面包屑缩小范围到几千行以内，AI 分析会更精准。
2. **提供上下文**：告诉 AI 你在排查什么问题（如"视频卡顿"、"连接超时"），而不是单纯问"这是什么"。
3. **持续对话**：如果第一次回答不够详细，可以追问"能详细说说 0x8004 这个错误码吗？"。
4. **应用建议后再问**：点击 AI 的过滤建议后，继续问"现在这些日志还有什么异常吗？"，形成递进式诊断。

---

## 🎹 高效快捷键映射 (Keyboard Shortcuts)

| 快捷键 | 功能 | 说明 |
| :--- | :--- | :--- |
| **`Ctrl + F`** | 快速聚焦顶部搜索框 | 独立查询模式 |
| **`Ctrl + H`** | 显示/隐藏底部搜索结果面板 | 查看全局搜索结果 |
| **`Ctrl + Wheel`** | 放大/缩小日志字体 | 动态调整字号 |
| **`任意字母/数字`** | 自动聚焦过滤框 | **VI 风格快速输入** |
| **`!`** | 切换 Exclude 模式 | 排除匹配内容（红色） |
| **`/`** | 切换 Regex 模式 | 正则表达式匹配（紫色） |
| **`=`** | 切换 Exact 模式 | 精确匹配，区分大小写（绿色） |
| **`?`** | 切换 AI 模式 | 智能分析诊断（蓝色） |
| **`:`** | 切换 Command 模式 | 指令控制（琥珀色） |
| **`@`** | 切换 Time 模式 | 时间点定位（青色） |
| **`Enter`** | 固化当前过滤条件 | 将当前搜索锁定为面包屑 |
| **`Esc`** | 智能导航 | 聚焦时退出输入框，未聚焦时删除最后一个面包屑 |

**⚡ Pro Tip**: 
- 按前缀键（如 `/`）后会自动聚焦输入框并切换到对应模式。
- 再次按同一个前缀键可取消模式，回到普通匹配。
- 输入完成后按 `Esc` 可快速退出输入框，无需动用鼠标。

---

## 🎯 典型工作流程示例

### 场景一：排查视频推流帧率异常（升级版）

1. **打开日志** → 系统自动识别出 12 个 Session（12 次系统启动）。
2. **选择目标 Session** → 点击第 5 个 Session（对应问题发生时间段）。
3. **启用踪迹模式** → 添加关键字 `video_callback`、`push_frame`（脱水后显示 2000 行）。
4. **VI 风格快速过滤** → 直接输入 `640` （无需点击输入框）→ 实时显示该分辨率的 200 行。
5. **固化面包屑** → 按 `Enter` 锁定 `640` 为面包屑。
6. **正则模式精准定位** → 按 `/` 切换到正则模式 → 输入 `fps:\s*\d+` → 定位到 15 行精准结果。
7. **时间差分析** → 观察 $\Delta$ 时间差标签，发现某些帧间隔超过 100ms。
8. **快速回退** → 按 `Esc` 删除正则过滤器，返回上一层视图。
9. **排除干扰** → 按 `!` 切换到排除模式 → 输入 `debug` → 过滤掉调试信息。
10. **导出结果** → 点击"导出结果"按钮，生成带原始行号的精简日志文件，提交给后端同事。

### 场景二：排查 `_dispatch_encodec_buffer` 在 AAC 编码上下文中的调用（新场景）

**背景**：用户发现音频编码失败，怀疑是 `_dispatch_encodec_buffer` 函数在特定编码器上下文中被错误调用。

1. **打开日志** → 加载 `audio_system.log`（300万行）。
2. **踪迹模式锁定编码器** → 添加关键字 `aac`（脱水后显示 5000 行）。
3. **设置上下文轮廓** → 调整"上下文行数"为 5 行，保留关键调用的环境信息。
4. **VI 快速搜索** → 直接输入 `_dispatch` （自动聚焦）→ 系统在扩展后的上下文窗口内搜索，显示 80 行结果。
5. **精确匹配锁定** → 按 `=` 切换精确模式 → 输入 `_dispatch_encodec_buffer` → 显示 12 行精准调用。
6. **时间差定位异常** → 在结果中发现某次调用的 $\Delta$ 时间差为 2000ms（正常应为 <50ms）。
7. **上下文分析** → 点击该行，查看前后 5 行上下文，发现编码器状态为 `PENDING`，确认是状态机异常。

**关键点**：新版本的三阶段过滤逻辑确保了即使 `_dispatch_encodec_buffer` 不直接包含 `aac`，只要它出现在 `aac` 行的上下文范围内，也能被精准捕获。

### 场景三：使用 AI 快速诊断未知错误（全新场景）

**背景**：用户在日志中看到大量 `attr_get_value:failed` 报错，但不清楚根因。

1. **打开日志** → 加载 `system.log`（150万行）。
2. **快速定位错误区域** → 按 `/` 启用正则模式 → 输入 `attr_get_value.*failed` → 筛选到 500 行。
3. **选择目标会话** → 点击 Session #2（问题高发时段）→ 筛选到 80 行。
4. **启动 AI 分析** → 按 `?` 切换到 AI 模式 → 输入 `为什么会出现这么多 attr_get_value 失败`。
5. **AI 智能诊断**：
   ```
   AI 回复：
   根据日志采样，attr_get_value 失败主要发生在 10:28:45 时间段，
   核心原因是 register_video_callback 和 register_audio_callback 
   被同时注册，导致音视频编码节点冲突（audio codec node is already attached）。
   
   建议关注以下关键事件：
   1. TCL_CMD_VIDEOSTART 和 TCL_CMD_AUDIOSTART 的调用时序
   2. 检查是否存在多路流同时启动的场景
   3. P2P 连接状态的切换时机
   
   推荐过滤建议：
   [/] TCL_CMD_(VIDEO|AUDIO)START || 过滤启动命令以分析时序
   [/] register.*callback || 聚焦回调注册逻辑
   [!] dayhight_intelligent || 排除智能夜视的干扰日志
   ```
6. **点击应用建议** → 点击第一个建议 `[/] TCL_CMD_(VIDEO|AUDIO)START`。
7. **面包屑自动更新** → 面包屑新增紫色标签 `/TCL_CMD_(VIDEO|AUDIO)START`，视图刷新到 15 行。
8. **验证假设** → 通过时间差分析，发现 VIDEOSTART 和 AUDIOSTART 确实在 5ms 内被连续调用。
9. **持续对话** → 在 AI 面板继续追问："能详细说说 audio codec node already attached 这个错误吗？"
10. **导出完整分析报告** → 点击导出按钮，将面包屑路径、AI 对话记录和精简日志一并保存，提交给开发团队。

**关键价值**：
- 从 150 万行日志到 15 行关键证据，AI 辅助下仅需 2 分钟。
- AI 的过滤建议基于专业的日志分析经验，避免了人工试错的盲目性。
- 面包屑路径完整记录了排查思路，方便团队复现和学习。

---

1. **打开仪表盘** → 选择"工作流分析"。
2. **定义任务对** → 起始标记：`TaskStart`，结束标记：`TaskComplete`，提取字段：`task_id`。
3. **全量扫描** → 系统自动配对 5000 个异步任务，计算 P95 延迟为 320ms。
4. **散点图定位** → 点击耗时 2000ms 的异常点，日志面板立即跳转到对应行。
5. **上下文分析** → 通过上下文轮廓查看该任务前后的日志，发现数据库连接超时。

---

## 🏆 与传统工具的对比

| 特性 | LogView | grep + vim | ELK Stack |
| :--- | :---: | :---: | :---: |
| **百万行秒开** | ✅ | ❌ (卡顿) | ✅ (需部署) |
| **多级面包屑过滤** | ✅ | ❌ | ❌ |
| **AI 智能诊断助手** | ✅ | ❌ | ❌ |
| **AI 过滤建议自动应用** | ✅ | ❌ | ❌ |
| **自定义 System Prompt** | ✅ | ❌ | ❌ |
| **VI 风格命令模式** | ✅ | 部分支持 | ❌ |
| **实时+固化混合模式** | ✅ | ❌ | ❌ |
| **脱水模式+上下文** | ✅ | ❌ | 部分支持 |
| **命令前缀 (!//=/?)** | ✅ | ❌ | ❌ |
| **时间差自动计算** | ✅ | ❌ | ❌ |
| **方案导出分享** | ✅ | ❌ | 复杂 |
| **本地离线使用** | ✅ | ✅ | ❌ (需服务器) |
| **键盘导航 (Esc/Enter)** | ✅ | 部分支持 | ❌ |
| **学习成本** | 低 (拖拽即用) | 高 (命令行) | 极高 (集群配置) |

---

## 💡 专家建议 (Pro Tips)

1. **先宽后窄的黄金法则**：不要一上来就输入复杂的长关键词。先用 Session 范围+踪迹模式大幅缩小范围，再通过面包屑逐层精细化。
2. **善用上下文轮廓**：在脱水模式下，设置 2-3 行上下文，既能聚焦关键路径，又不会丢失环境信息。尤其在排查函数调用顺序时，上下文能提供完整的执行链条。
3. **时间差是性能分析的天眼**：如果 $\Delta$ 时间差突然从 10ms 跳到 500ms，问题往往就在这两行之间。
4. **面包屑是团队沟通的桥梁**：导出配置时，面包屑路径会被保存，同事导入后可以"原路重现"你的分析过程。
5. **实时模式试探，固化模式锁定**：不确定关键词时，先在输入框中快速试探（实时响应），找到精准词后按 `Enter` 锁定，继续下一层。
7. **⚡ VI 风格极速操作**：
   - 看到感兴趣的关键词？直接输入，无需点击搜索框。
   - 想排除某类日志？按 `!` 直接切换到排除模式。
   - 需要用正则？按 `/` 立即启用，无需在设置中切换。
   - 想问 AI？按 `?` 直接对话，AI 会基于当前过滤结果给出专业建议。
8. **Esc 键是你的"后悔药"**：
   - 输错了？按 `Esc` 退出输入框并清空预览。
   - 过滤太深了？连按几次 `Esc` 逐级回退面包屑。
9. **精简过滤在上下文窗口内工作**：不要担心精简关键词"不在种子行上"。只要它在上下文范围内，系统就能精准捕获（这是 v2.0 的核心优化）。
10. **善用 AI 的过滤建议**：AI 建议的过滤条件都是基于专业分析经验，点击应用后往往能快速定位到核心问题。如果不满意，直接按 `Esc` 删除该面包屑即可。
11. **自定义 AI 的专家角色**：如果你的日志属于特定领域（如音视频、网络协议、数据库），在配置面板中自定义 System Prompt，让 AI 更懂你的业务。

---

## 🚧 技术架构亮点

*   **前端**: React 19 + TypeScript + Zustand (状态管理) + Tailwind CSS + react-markdown (AI 对话渲染)
*   **后端**: Rust + Tauri 2.0 + Rayon (并行计算) + mmap (内存映射) + reqwest (HTTP 客户端，AI 接口调用)
*   **AI 集成**: OpenAI 兼容接口 (支持 OpenAI / DeepSeek / Claude / Ollama 等)
*   **虚拟化渲染**: react-virtuoso (百万行流畅滚动)
*   **持久化**: localStorage (前端状态) + JSON 配置文件
*   **性能数据**: 200 万行日志加载时间 < 2 秒，过滤响应时间 < 50 毫秒，AI 分析响应时间 < 3 秒 (取决于 API 延迟)

---

## 📞 反馈与支持

如果你在使用过程中发现了 Bug，或者有新的功能建议，欢迎通过以下方式联系我们：

*   **GitHub Issues**: [项目地址待补充]
*   **内部工作群**: [待补充]

---

**LogView v1.2.0 —— 让日志分析变成一门艺术。从手工排查到 AI 自动诊断的革命性跨越。** 🎨🤖
